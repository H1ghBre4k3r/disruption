use serde::{Deserialize, Serialize};

use crate::{
    channel::{ChannelApiType, ChannelMentionApiType},
    entities::{ApplicationApiType, UserApiType},
    resources::{PollApiType, StickerApiType, StickerItemApiType},
};

use super::{
    AttachmentApiType, EmbedApiType, MessageActivityApiType, MessageCallApiType,
    MessageComponentApiType, MessageInteractionApiType, MessageInteractionMetadataApiType,
    MessageReferenceApiType, MessageSnapshotApiType, MessageTypeApiType, ReactionApiType,
    RoleSubscriptionDataApiType,
};

/// <https://discord.com/developers/docs/resources/channel#message-object>
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct MessageApiType {
    /// id of the message
    pub id: String,
    /// id of the channel the message was sent in
    pub channel_id: String,
    /// the author of this message (not guaranteed to be a valid user, see below)
    pub author: UserApiType,
    /// contents of the message
    pub content: String,
    /// when this message was sent
    pub timestamp: String,
    /// when this message was edited (or null if never)
    pub edited_timestamp: Option<String>,
    /// whether this was a TTS message
    pub tts: bool,
    /// whether this message mentions everyone
    pub mention_everyone: bool,
    /// users specifically mentioned in the message
    pub mentions: Vec<UserApiType>,
    /// roles specifically mentioned in this message (as snowflakes)
    pub mention_roles: Vec<String>,
    /// channels specifically mentioned in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mention_channels: Option<Vec<ChannelMentionApiType>>,
    /// any attached files
    pub attachments: Vec<AttachmentApiType>,
    /// any embedded content
    pub embeds: Vec<EmbedApiType>,
    /// reactions to this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reactions: Option<Vec<ReactionApiType>>,
    /// used for validating a message was sent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<serde_json::Value>, // Can be integer or string
    /// whether this message is pinned
    pub pinned: bool,
    /// if the message is generated by a webhook, this is the webhook's id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_id: Option<String>,
    /// type of the message
    #[serde(rename = "type")]
    pub type_: MessageTypeApiType,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activity: Option<MessageActivityApiType>,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application: Option<ApplicationApiType>,
    /// if the message is an interaction or application-owned webhook, this is the id of the application
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_id: Option<String>,
    /// message flags combined as a bitfield
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flags: Option<u64>,
    /// data showing the source of a crosspost, channel follow add, pin, or reply message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_reference: Option<MessageReferenceApiType>,
    /// the message associated with the message_reference (minimal subset of fields)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_snapshots: Option<Vec<MessageSnapshotApiType>>,
    /// the message associated with the message_reference
    #[serde(skip_serializing_if = "Option::is_none")]
    pub referenced_message: Box<Option<MessageApiType>>,
    /// Sent if the message is sent as a result of an interaction
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction_metadata: Option<MessageInteractionMetadataApiType>,
    /// Deprecated in favor of interaction_metadata; sent if the message is a response to an interaction
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction: Option<MessageInteractionApiType>,
    /// the thread that was started from this message, includes thread member object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread: Option<ChannelApiType>,
    /// sent if the message contains components like buttons, action rows, or other interactive components
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<MessageComponentApiType>>,
    /// sent if the message contains stickers
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sticker_items: Option<Vec<StickerItemApiType>>,
    /// Deprecated - the stickers sent with the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stickers: Option<Vec<StickerApiType>>,
    /// approximate position of the message in a thread
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<u32>,
    /// data of the role subscription purchase or renewal that prompted this ROLE_SUBSCRIPTION_PURCHASE message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_subscription_data: Option<RoleSubscriptionDataApiType>,
    /// data for users, members, channels, and roles referenced in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved: Option<serde_json::Value>, // TODO: Use proper Resolved type when implemented
    /// A poll!
    #[serde(skip_serializing_if = "Option::is_none")]
    pub poll: Option<PollApiType>,
    /// the call associated with the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub call: Option<MessageCallApiType>,
}

impl<T> From<T> for MessageApiType
where
    T: ToString,
{
    fn from(value: T) -> Self {
        MessageApiType {
            content: value.to_string(),
            ..Default::default()
        }
    }
}
